const e=(e,t)=>e.replace(t,""),t={"#":new RegExp("\\d"),"&":new RegExp("[a-zA-Z]"),"@":new RegExp("[a-zA-Z0-9]"),$:new RegExp("[^a-zA-Z0-9\\s]")},n=new RegExp("[#@&\\$]","gi"),r=new RegExp("[,\\.\\/(\\[\\{\\}\\])|\\-_\\*\\^:;\\|—¯]","g"),a=e=>e.join(""),o=(n,o)=>{const{clean:c}=o;return((t,n)=>{const o=new RegExp(`${r.source}*ø.*`,"g"),c=[...t].reduce((e,t)=>e.replace("ø",t),a(n.blind)),l=e(c,o),{clean:u,raw:s}=n;return{clean:u,output:l,completed:l.length===s.length}})([...n].reduce((e,n,r,a)=>{const o=t[c[r]];return t[c[r+1]]&&o||a.splice(0),o&&o.test(n)?e+n:e},""),o)},c=t=>{const n=a(t);return e(n,r)},l=t=>{const a=e(t,r),o=a.match(n)||"";if(a.length!==o.length)throw new Error("The mask has some invalid pattern character.");return o},u=e=>{const t=(Array.isArray(e)?e:[e]).map(e=>(e=>{const t=[...e];return{raw:t,clean:l(e),blind:(r=t,r.map(e=>e.match(n)?"ø":e))};var r})(e));return t.sort((e,t)=>{if(c(e.raw)===c(t.raw))throw new Error("Two or more masks have the same amount of input characters. You must correct it.");return e.clean.length-t.clean.length})},s=t=>e(t.output,r).length,p=()=>null,i=({input:t,pattern:n,onSuccess:a=p,onError:c=p,validation:l=p})=>{const i=u(n),d=e(t,r),g=i.map(e=>o(d,e)),h=g.sort((e,t)=>s(t)-s(e)).filter((e,t,n)=>s(e)===s(n[0])).filter((e,t,n)=>n.some(e=>e.completed)?e.completed:e).reduce((e,t)=>e.clean.length<t.clean.length?e:t);const{completed:m,output:w}=h,E=l(w);if(!1===E)c();else{(m?a:c)()}return{input:t,output:w,completed:m,isValid:E}};export default function mdg({pattern:e,onError:t,onSuccess:n,validation:r}){const a={pattern:e,onError:t,onSuccess:n,validation:r},o=e=>i({input:e,...a}),c={...a,checkValue:o,checkField:(e,t="input")=>{e.addEventListener(t,e=>{const t=e.target;t.value=o(t.value).output})}};return Object.freeze(c),c}
